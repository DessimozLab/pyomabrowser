{% load staticfiles %}

<script src="{% static 'js/vue.js' %}"></script>

<style>

    .button_search {
        height: 100%;
        background-color: transparent;
        border: none;
        margin-right: 4px;
        margin-left: auto;
        order: 2;
    }


    .help_icon {
        font-size: 1.5em;
        transform: translate(0,25%);
         margin: 4px;
        cursor: pointer;
    }

    .prefix-dropdown {
        border: none;
        background-color: transparent;
    }

    .vl {
        border-left: 2px solid grey;
        margin-left: 4px;
        margin-right: 4px;
    }

    #{{ unique_id }}_input_part {

        display: flex;
        border: 1px solid #eee;
        font-size: 0.9em;
        height: 50px;
        box-sizing: border-box;
        padding: 0 0 0 4px;
        border-radius: 500px;
    }

    .token-input__tag {
        height: 30px;
        display: inline-block;
        margin-right: 10px;
        background-color: #eee;
        margin-top: 10px;
        line-height: 30px;
        padding: 0 5px;
        border-radius: 5px;
    }

    .token-input__tag > span {
        cursor: pointer;
        opacity: 0.75;
    }

    .token-input__text {
        border: none;
        outline: none;
        font-size: 0.9em;
        line-height: 50px;
        flex-grow: 1;
        background: transparent;
    }

    .token-delete {
        margin-left: 4px;
        color: red;
    }

    #token-container_{{ unique_id }}{
        white-space: nowrap;
        overflow: scroll;
        display: inline;

    }

</style>

<script type="module">

    const {createApp} = Vue

    window.search_token_vue_{{ unique_id }} = createApp({
        data() {
            return {
                tokens: [], //{query: 'HUMAN', single_term: true, prefix: "Species", type: "Taxon"}
                prefixes: {
                    'Protein': ['proteinid','xref','go','ec','description','domain','sequence'],
                    'Taxon': ['species','taxid', 'taxon'],
                    'HOG': ['hog','sequence'],
                    'OMA Group': ['og', 'fingerprint','sequence'],
                },
                default_prefix : 'description',
                show_error: false,
                error_message : " Error.",
                post_query: '',
                wild_card: 'sequence',
                placeholder: ' "Blue-light photoreceptor" | proteinid:P53_RAT  | species:"Drosophila melanogaster" ',  //'P53_RAT | Insulin | species:HUMAN | "auxin response factor"',
                placeholder_default: 'proteinid:P53_RAT | "Blue-light photoreceptor" | species:"Drosophila melanogaster" '  //'P53_RAT | Insulin | species:HUMAN | "auxin response factor"',
            }
        },
        compilerOptions: {
            delimiters: ["$[", "]$"]
        },
        methods: {
            get_list_prefixes(lowercase=false){

                var lp = [].concat(...Object.values(this.prefixes))

                if (lowercase){

                    lp = lp.map(element => {return element.toLowerCase();});
                }
                return lp
            },
            get_prefix_used(){
                return this.tokens.map(x => this.get_type_prefix(x.prefix));
            },
            get_type_prefix(prefix){
                for (var key in this.prefixes) {
                    if (this.prefixes.hasOwnProperty(key)) {
                        if (this.prefixes[key].includes(prefix.toLowerCase())){
                            return key
                        }
                    }
                }
                return null
            },
            addToken(event) {

                event.preventDefault()
                var val = event.target.value.trim()


                if (val.length == 0 && this.tokens.length > 0){
                    this.collect_token()
                    // wanted to auto search if press and empty + token but post request miss post_query data
                }
                else {

                    var sinle_term = val[0] != '"';
                    var multi_term_closed = (val.length > 1 && val[val.length - 1] == '"')
                    var has_prefix = val.includes(':')
                    var prefix_end = val[val.length - 1] == ':'
                    var p = has_prefix ? val.split(':')[0] : this.default_prefix;


                    // If prefix but not valid
                    if (has_prefix && !this.get_list_prefixes(true).includes(p.toLowerCase())) {
                        this.show_error = true;
                        this.error_message = "Error: Incorrect prefix."
                        return;
                    } else {
                        this.show_error = false;
                    }

                    // If something typed
                    if (val.length > 0) {

                        // Multiple word query
                        if (!sinle_term) {

                            // STOP if multiple not closed
                            if (!multi_term_closed) {

                                if (event.code == "Space") {
                                    event.target.value = val + ' '
                                }
                                return
                            }
                        }

                        // STOP if the prefix is fine and we are at :
                        if (prefix_end) {
                            return
                        }

                        // has a prefix
                        if (has_prefix) {

                            var tmp = val.split(':')[1].trim()
                            sinle_term = tmp[0] != '"';
                            multi_term_closed = (val.length > 1 && tmp[tmp.length - 1] == '"')


                            // multiple term
                            if (!sinle_term) {

                                // STOP if not closed
                                if (!multi_term_closed) {
                                    if (event.code == "Space") {
                                        event.target.value = val + ' '
                                    }
                                    return
                                }


                            }
                            val = tmp
                        }


                        if (this.validate_token(val.replaceAll('"', ''), sinle_term, p)) {
                            val = val.replaceAll('"', '')
                            this.tokens.push({
                                query: val,
                                single_term: sinle_term,
                                prefix: p,
                                type: this.get_type_prefix(p)
                            });
                            event.target.value = '';
                        }


                    }
                }


            },
            removeToken(index) {
                this.tokens.splice(index, 1)
            },
            removeLastToken(event) {
                if (event.target.value.length === 0) {
                    this.removeToken(this.tokens.length - 1)
                }
            },
            collect_token(){
                this.post_query = JSON.stringify(this.tokens)
            },
            detokenize(index){
                var token = this.tokens.splice(index, 1)[0];
                var input_token_search = document.getElementById('input_token_search_{{ unique_id }}');
                var token_str = token.prefix + ': '
                token_str += token.single_term ? '' : '"'
                token_str += token.query
                token_str += token.single_term ? '' : '"'

                input_token_search.value =  token_str


            },
            on_change_prefix(target, t){
                var prefix = target.value
                if (this.validate_token(t.query, t.single_term,prefix)){
                    t.prefix = prefix.toLowerCase()
                }
                else {
                    target.value = t.prefix;
                }

            },
            validate_token(val, sinle_term, p ){

                if (this.wild_card.includes(p)){
                    return true
                }

                // todo Validate type val is valid for p

                // validate prefix not in conflict with other prefix
                var pu = this.get_prefix_used();
                var current_prefix_type = this.get_type_prefix(p)

                if (current_prefix_type != 'Taxon'){

                    var no_taxon = pu.filter(x => x !== 'Taxon');

                    if (no_taxon.length > 0 && no_taxon[0] != current_prefix_type ) {
                        this.show_error = true;
                            this.error_message = "Warning: You are searching for " + no_taxon[0] +
                                " you can't add token for " + current_prefix_type
                            return false
                    }

                }

                return true

            },
            preload_token(tokens){
                this.tokens = []
                for (var i in tokens) {
                    var token = tokens[i]
                    if (this.validate_token(token.query, token.sinle_term, token.prefix )){
                        this.tokens.push({query: token.query, single_term: token.sinle_term, prefix: token.prefix, type:token.type});
                    }
                }
                this.placeholder = ''

            },
            is_empty(){return tokens.length == 0 ? true : false},
            modal_clicked(){
                console.log('clicked')
                $('#exampleModal_{{ unique_id }}').modal('show')
            }
        },
    }).mount('#{{ unique_id }}')

    var autocomplete_opts = {

        paramName: 'search',
        serviceUrl: '/api/xref/',
        minChars: 3,
        triggerSelectOnValidInput: false,
        deferRequestBy: 200,
        transformResult: function (response) {
            var json = JSON.parse(response);
            var xref_source_order = {{ xref_order | safe }};
            json.sort(function (a, b){
                var idx_a = xref_source_order.indexOf(a.source), idx_b = xref_source_order.indexOf(b.source);
                if (idx_a === idx_b){
                    return a.xref > b.xref ? 1 : -1;
                }
                return idx_a - idx_b;
            });
            return {
                suggestions: $.map(json, function (dataItem) {
                    return {value: dataItem.xref, data: dataItem};
                })
            };
        },
        groupBy: 'source',
        formatResult: function(suggestion, currentValue) {
            // Do not replace anything if there current value is empty
            if (!currentValue) {
                return suggestion.value;
            }
            // escape any special char
            var pattern = '(' + currentValue.replace(/[|\\{}()[\]^$+*?.]/g, "\\$&") + ')';
            var highlight_and_escape = function(val){
                return val.replace(new RegExp(pattern, 'gi'), '<strong>$1<\/strong>')
                    .replace(/&/g, '&amp;')
                    .replace(/</g, '&lt;')
                    .replace(/>/g, '&gt;')
                    .replace(/"/g, '&quot;')
                    .replace(/&lt;(\/?strong)&gt;/g, '<$1>');
            };
            var label = '<span class="auto-xref">' + highlight_and_escape(suggestion.data.xref) +'</span> &nbsp;'+
                        '<span class="auto-omaid">' + suggestion.data.omaid + '</span>'+
                        '<span class="auto-species">' + highlight_and_escape(suggestion.data.genome.species) + '</span>';
            return label;
        },
        onSelect: function(item){
            window.location.href = "/oma/vps/" + item.data.entry_nr;
            return false;
        },
        response: function( event, ui ) {console.log('HOG')}

    };
    $('#input_token_search_{{ unique_id }}').autocomplete(autocomplete_opts);


</script>


<!-- Modal -->
<div class="modal fade" data-backdrop="false" id="exampleModal_{{ unique_id }}" tabindex="-1" aria-labelledby="exampleModalLabel{{ unique_id }}" aria-hidden="true">
  <div class="modal-dialog modal-lg modal-dialog-centered" >
    <div class="modal-content">
      <div class="modal-header">
        <h4 class="modal-title" id="exampleModalLabel{{ unique_id }}">How to use the search in OMA Browser ?</h4>
        <button type="button" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body" style="text-align: justify">

          <strong>How did the search works ?</strong>

          <p>It works like a normal input field but everytime you press "Space" or "Enter" after a word, a token will be
              created composed of the inputted term and of a prefix that  describe how the term should be treated.</p>

          <strong>But how can I search for a multi word query then?</strong>

          <p>If your query term is composed of multiple word (e.g homo sapiens) you can use " " to encapsulate it. Of there is an open " the space and enter
          key will not triggered the tokenisation until a closing " is present!</p>

          <strong>But how many tokens can i can have ? Is there different types ?</strong>

          <p>There is not limit on the number of tokens but there is some rules to respect.
          Each tokens is associated to one of the four big categories of entries in OMA browser: Genes, HOGs, OMA groups and Taxon with their
              associated prefix:
              <ul>
          <li><b>Genes:</b> 'proteinid', 'xref', 'go', 'ec', 'description', 'domain', 'sequence'</li>
          <li><b>HOGs:</b> 'species', 'taxid', 'taxon'</li>
          <li><b>OMA groups:</b> 'hog', 'sequence'</li>
          <li><b>Taxon:</b> 'og', 'fingerprint', 'sequence'</li>
      </ul>

          Except for taxon that you can combined or use alone, you can't search for more that one type at once
          (e.g hog:12 with xref:HUMAN_1234 don't make sense but fingerprint:'EWGKQSF' in species:Tetraodon is fine).
          </p>


          <strong>Oups a typo !</strong>

          <p>No problems, you edit your token. Click on the term, the token will be stringify so you can modify it.

              <br>
              The prefix is not correct ? You can click on the dropdown icon to select an other one.

              <br>
              I dont want this token.. Just clikc on the x to delete it.

          </p>







      </div>
      <div class="modal-footer">
        <button type="button" class="btn btn-secondary" data-dismiss="modal">Close</button>
      </div>
    </div>
  </div>
</div>


<form method="POST" id='form_' action="{% url 'search_token' %}" >
            {% csrf_token %}

<div id="{{ unique_id }}">

    <div id="{{ unique_id }}_input_part">


        <span class="material-symbols-outlined help_icon" @click="modal_clicked">
help
</span>


        <div id="token-container_{{ unique_id }}">



    <span v-for="token, index in tokens" :key="token" class="token-input__tag">


        <select class="prefix-dropdown" @change="on_change_prefix($event.target, token)">

               <template v-for="(prefixes_list, prefix_type) in prefixes">
    <optgroup :label="prefix_type" >
    <option v-for="prefix in prefixes_list" :key="prefix" :selected="prefix == token.prefix">
                $[ prefix ]$
            </option>
         </optgroup>
  </template>

        </select>

        <span class="vl"></span>

        <p style="display: inline" @click='detokenize(index)'>$[ token.query ]$</p>

        <span @click='removeToken(index)' class="token-delete">X</span>

        </select>

    </span>

    </div>

    <input type="hidden" name="hidden_query" :value="post_query">

    <input type='text' :placeholder='placeholder'  class='token-input__text' id="input_token_search_{{ unique_id }}"
           @keydown.enter='addToken'
           @keydown.space='addToken'
           @keydown.delete='removeLastToken'
    />

    <button class=" button_search float-right" id="button_submit" @click='collect_token()' type="submit">
        <img  style='width: 24px;' src="{% static "image/logo-oma-o.svg" %}" alt="Logo OMA icon"/>
    </button>

    </div>


    <div style="display: flex" v-show="show_error">
        <small style="color: red; margin-right: auto;" > $[this.error_message]$  </small>
    </div>



</div>

 </form>
