{% load staticfiles %}

<script src="{% static 'js/vue.js' %}"></script>

<style>

    .button_search {
        height: 100%;
        background-color: transparent;
        border: none;
        margin-right: 4px;
        margin-left: auto;
        order: 2;
    }

    .prefix-dropdown {
        border: none;
        background-color: transparent;
    }

    .vl {
        border-left: 2px solid grey;
        margin-left: 4px;
        margin-right: 4px;
    }

    #{{unique_id}} {

        display: flex;
        border: 1px solid #eee;
        font-size: 0.9em;
        height: 50px;
        box-sizing: border-box;
        padding: 0 0 0 10px;
        border-radius: 8px;
    }

    .token-input__tag {
        height: 30px;
        display: inline-block;
        margin-right: 10px;
        background-color: #eee;
        margin-top: 10px;
        line-height: 30px;
        padding: 0 5px;
        border-radius: 5px;
    }

    .token-input__tag > span {
        cursor: pointer;
        opacity: 0.75;
    }

    .token-input__text {
        border: none;
        outline: none;
        font-size: 0.9em;
        line-height: 50px;
        flex-grow: 1;
        background: transparent;
    }

    .token-delete {
        margin-left: 4px;
        color: red;
    }

    #token-container_{{ unique_id }}{
        white-space: nowrap;
        overflow: scroll;
        display: inline;

    }

</style>

<script type="module">

    const {createApp} = Vue

    window.search_token_vue_{{ unique_id }} = createApp({
        data() {
            return {
                tokens: [], //{query: 'HUMAN', single_term: true, prefix: "Species", type: "Taxon"}
                prefixes: {
                    'Protein': ['proteinID','xref','go','ec','description','domain','sequence'],
                    'Taxon': ['species','taxid', 'taxon'],
                    'HOG': ['hog','sequence'],
                    'OMA Group': ['og', 'fingerprint','sequence'],
                },
                default_prefix : 'description',
                show_error: false,
                error_message : " Error.",
                post_query: '',
                wild_card: 'sequence'
            }
        },
        compilerOptions: {
            delimiters: ["$[", "]$"]
        },
        methods: {
            get_list_prefixes(lowercase=false){

                var lp = [].concat(...Object.values(this.prefixes))

                if (lowercase){

                    lp = lp.map(element => {return element.toLowerCase();});
                }
                return lp
            },
            get_prefix_used(){
                return this.tokens.map(x => this.get_type_prefix(x.prefix));
            },
            get_type_prefix(prefix){
                for (var key in this.prefixes) {
                    if (this.prefixes.hasOwnProperty(key)) {
                        if (this.prefixes[key].includes(prefix.toLowerCase())){
                            return key
                        }
                    }
                }
                return null
            },
            addToken(event) {

                event.preventDefault()
                var val = event.target.value.trim()

                var sinle_term = val[0] != '"';
                var multi_term_closed = (val.length > 1 && val[val.length - 1] == '"')
                var has_prefix = val.includes(':')
                var prefix_end = val[val.length - 1] == ':'
                var p = has_prefix ? val.split(':')[0] : this.default_prefix;


                // If prefix but not valid
                if (has_prefix && !this.get_list_prefixes(true).includes(p.toLowerCase())) {
                    this.show_error = true;
                    this.error_message = "Error: Incorrect prefix."
                    return;
                } else {
                    this.show_error = false;
                }

                // If something typed
                if (val.length > 0) {

                    // Multiple word query
                    if (!sinle_term) {

                        // STOP if multiple not closed
                        if (!multi_term_closed) {

                            if (event.code == "Space") {
                                event.target.value = val + ' '
                            }
                            return
                        }
                    }

                    // STOP if the prefix is fine and we are at :
                    if (prefix_end) {
                        return
                    }

                    // has a prefix
                    if (has_prefix) {

                        var tmp = val.split(':')[1].trim()
                        sinle_term = tmp[0] != '"';
                        multi_term_closed = (val.length > 1 && tmp[tmp.length - 1] == '"')


                        // multiple term
                        if (!sinle_term) {

                            // STOP if not closed
                            if (!multi_term_closed) {
                                if (event.code == "Space") {
                                    event.target.value = val + ' '
                                }
                                return
                            }


                        }
                        val = tmp
                    }



                    if (this.validate_token(val.replaceAll('"', ''), sinle_term, p )){
                        val = val.replaceAll('"', '')
                         console.log(val, sinle_term, p)
                        this.tokens.push({query: val, single_term: sinle_term, prefix: p, type:this.get_type_prefix(p)});
                        event.target.value = '';
                    }


                }

            },
            removeToken(index) {
                this.tokens.splice(index, 1)
            },
            removeLastToken(event) {
                if (event.target.value.length === 0) {
                    this.removeToken(this.tokens.length - 1)
                }
            },
            collect_token(){
                this.post_query = JSON.stringify(this.tokens)
            },
            detokenize(index){
                var token = this.tokens.splice(index, 1)[0];
                var input_token_search = document.getElementById('input_token_search_{{ unique_id }}');
                var token_str = token.prefix + ': '
                token_str += token.single_term ? '' : '"'
                token_str += token.query
                token_str += token.single_term ? '' : '"'

                input_token_search.value =  token_str


            },
            on_change_prefix(prefix, t){
                t.prefix = prefix.toLowerCase()
            },
            validate_token(val, sinle_term, p ){

                if (this.wild_card.includes(p)){
                    return true
                }

                // todo Validate type val is valid for p

                // validate prefix not in conflict with other prefix
                var pu = this.get_prefix_used();
                var current_prefix_type = this.get_type_prefix(p)



                if (current_prefix_type != 'Taxon'){

                    var no_taxon = pu.filter(x => x !== 'Taxon');

                    if (no_taxon.length > 0 && no_taxon[0] != current_prefix_type ) {
                        this.show_error = true;
                            this.error_message = "Warning: You are searching for " + no_taxon[0] +
                                " you can't add token for " + current_prefix_type
                            return false
                    }

                }

                return true

            },
            preload_token(tokens){
                for (var i in tokens) {
                    var token = tokens[i]
                    if (this.validate_token(token.query, token.sinle_term, token.prefix )){
                        this.tokens.push({query: token.query, single_term: token.sinle_term, prefix: token.prefix, type:token.type});
                    }
                }
            }
        },
    }).mount('#{{ unique_id }}')


</script>

<form method="POST" action="{% url 'search_token' %}" >
            {% csrf_token %}

<div id="{{ unique_id }}">

    <div id="token-container_{{ unique_id }}">

    <span v-for="token, index in tokens" :key="token" class="token-input__tag">


        <select class="prefix-dropdown" @change="on_change_prefix($event.target.value, token)">

               <template v-for="(prefixes_list, prefix_type) in prefixes">
    <optgroup :label="prefix_type" >
    <option v-for="prefix in prefixes_list" :key="prefix" :selected="prefix == token.prefix">
                $[ prefix ]$
            </option>
         </optgroup>
  </template>



        </select>

        <span class="vl"></span>

        <p style="display: inline" @click='detokenize(index)'>$[ token.query ]$</p>

        <span @click='removeToken(index)' class="token-delete">X</span>

        </select>

    </span>

    </div>

    <input type="hidden" name="hidden_query" :value="post_query">

    <input type='text' placeholder="Enter your query"  class='token-input__text' id="input_token_search_{{ unique_id }}"
           @keydown.enter='addToken'
           @keydown.space='addToken'
           @keydown.delete='removeLastToken'
    />

    <button class=" button_search float-right" @click='collect_token()' type="submit">
        <img  style='width: 24px;' src="{% static "image/logo-oma-o.svg" %}" alt="Logo OMA icon"/>
    </button>



    <p style="color: red" v-show="show_error"> $[this.error_message]$  </p>


</div>

 </form>
