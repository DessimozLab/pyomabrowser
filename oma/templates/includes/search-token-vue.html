{% load staticfiles %}

<script src="{% static 'js/vue.js' %}"></script>

<style>

    .button_search {
        height: 100%;
        background-color: transparent;
        border: none;
        margin-right: 4px;
    }

    .prefix-dropdown {
        border: none;
        background-color: transparent;
    }

    .vl {
        border-left: 2px solid grey;
        margin-left: 4px;
        margin-right: 4px;
    }

    #token-input {
        width: 80%;
        border: 1px solid #eee;
        font-size: 0.9em;
        height: 50px;
        box-sizing: border-box;
        padding: 0 0 0 10px;
        border-radius: 8px;
    }

    .token-input__tag {
        height: 30px;
        display: inline-block;
        margin-right: 10px;
        background-color: #eee;
        margin-top: 10px;
        line-height: 30px;
        padding: 0 5px;
        border-radius: 5px;
    }

    .token-input__tag > span {
        cursor: pointer;
        opacity: 0.75;
    }

    .token-input__text {
        border: none;
        outline: none;
        font-size: 0.9em;
        line-height: 50px;
        background: none;
        width: calc(40% - 48px);
    }

    .token-delete {
        margin-left: 4px;
        color: red;
    }

    #token-container{
        white-space: nowrap;
        float:left;
        max-width: 60%;
        overflow: scroll;
        display: inline;
    }

</style>


<script type="module">

    const {createApp} = Vue

    createApp({
        data() {
            return {
                tokens: [], //{query: 'HUMAN', single_term: true, prefix: "Species"}
                prefixes: {
                    'Protein': ['ProteinID','XRef','GO','EC','Description','Domain','Seq'],
                    'Taxon': ['Name','TaxId'],
                    'HOG': ['HOG'],
                    'OMA Group': ['Number', 'Fingerprint'],
                },
                default_prefix : 'Description',
                show_error: false,
                error_message : " Error.",
                post_query: ''
            }
        },
        compilerOptions: {
            delimiters: ["$[", "]$"]
        },
        methods: {
            get_list_prefixes(){
                return [].concat(...Object.values(this.prefixes))
            },
            get_prefix_used(){
                return this.tokens.map(x => this.get_type_prefix(x.prefix));
            },
            get_type_prefix(prefix){
                for (var key in this.prefixes) {
                    if (this.prefixes.hasOwnProperty(key)) {
                        if (this.prefixes[key].includes(prefix)){
                            return key
                        }
                    }
                }
                return null
            },
            addToken(event) {

                event.preventDefault()
                var val = event.target.value.trim()

                var sinle_term = val[0] != '"';
                var multi_term_closed = (val.length > 1 && val[val.length - 1] == '"')
                var has_prefix = val.includes(':')
                var prefix_end = val[val.length - 1] == ':'
                var p = has_prefix ? val.split(':')[0] : this.default_prefix;


                // If prefix but not valid
                if (has_prefix && !this.get_list_prefixes().includes(p)) {
                    this.show_error = true;
                    this.error_message = "Error: Incorrect prefix."
                    return;
                } else {
                    this.show_error = false;
                }

                // If something typed
                if (val.length > 0) {

                    // Multiple word query
                    if (!sinle_term) {

                        // STOP if multiple not closed
                        if (!multi_term_closed) {

                            if (event.code == "Space") {
                                event.target.value = val + ' '
                            }
                            return
                        }
                    }

                    // STOP if the prefix is fine and we are at :
                    if (prefix_end) {
                        return
                    }

                    // has a prefix
                    if (has_prefix) {

                        var tmp = val.split(':')[1]
                        sinle_term = tmp[0] != '"';
                        multi_term_closed = (val.length > 1 && tmp[tmp.length - 1] == '"')


                        // multiple term
                        if (!sinle_term) {

                            // STOP if not closed
                            if (!multi_term_closed) {
                                if (event.code == "Space") {
                                    event.target.value = val + ' '
                                }
                                return
                            }


                            tmp = tmp.slice(1, -1);

                        }
                        val = tmp
                    }

                    if (this.validate_token(val, sinle_term, p )){
                        this.tokens.push({query: val, single_term: sinle_term, prefix: p});
                        event.target.value = '';
                    }


                }

            },
            removeToken(index) {
                this.tokens.splice(index, 1)
            },
            removeLastToken(event) {
                if (event.target.value.length === 0) {
                    this.removeToken(this.tokens.length - 1)
                }
            },
            collect_token(){
                this.post_query = JSON.stringify(this.tokens)
            },
            detokenize(index){
                var token = this.tokens.splice(index, 1)[0];
                var input_token_search = document.getElementById('input_token_search');
                var token_str = token.prefix + ': '
                token_str += token.single_term ? '' : '"'
                token_str += token.query
                token_str += token.single_term ? '' : '"'

                input_token_search.value =  token_str


            },
            on_change_prefix(prefix, t){
                t.prefix = prefix
            },
            validate_token(val, sinle_term, p ){

                // Validate type val is valid for p

                // validate prefix not in conflict with other prefix
                var pu = this.get_prefix_used();
                var current_prefix_type = this.get_type_prefix(p)




                if (current_prefix_type != 'Taxon'){

                    var no_taxon = pu.filter(x => x !== 'Taxon');

                    if (no_taxon.length > 0){
                        this.show_error = true;
                            this.error_message = "Error: You can't have twice the same prefix except for Taxon."
                            return false
                    }

                }

                return true

            }
        },
    }).mount('#token-input')


</script>

 <form method="POST" action="{% url 'search_token' %}" >
            {% csrf_token %}

<div id="token-input">



    <div id="token-container">

    <span v-for="token, index in tokens" :key="token" class="token-input__tag">


        <select class="prefix-dropdown" @change="on_change_prefix($event.target.value, token)">

               <template v-for="(prefixes_list, prefix_type) in prefixes">
    <optgroup :label="prefix_type" >
    <option v-for="prefix in prefixes_list" :key="prefix" :selected="prefix == token.prefix">
                $[ prefix ]$
            </option>
         </optgroup>
  </template>



        </select>

        <span class="vl"></span>

        <p style="display: inline" @click='detokenize(index)'>$[ token.query ]$</p>

        <span @click='removeToken(index)' class="token-delete">X</span>

        </select>

    </span>

    </div>



        <input type="hidden" name="hidden_query" :value="post_query">

    <input type='text' placeholder="Enter your query"  class='token-input__text' id="input_token_search"
           @keydown.enter='addToken'
           @keydown.space='addToken'
           @keydown.delete='removeLastToken'
    />

    <button class=" button_search float-right" @click='collect_token()' type="submit">
        <img  style='width: 24px;' src="{% static "image/logo-oma-o.svg" %}" alt="Logo OMA icon"/>
    </button>



    <p style="color: red" v-show="show_error"> $[this.error_message]$  </p>


</div>

 </form>
