<!DOCTYPE html>
<meta charset="utf-8">
<style>

path {
  stroke: #fff;
}

div.tooltip {
    position: absolute;
    text-align: center;
    max-width: 220px;
    min-width: 200px;
    max-height: 380px;
    min-height: 100px;
    padding: 6px;
    color: azure;
    font: 10px "Helvetica Neue", Helvetica, Arial, "Droid sans", sans-serif;
    background: #4B79A1;
    background: -webkit-linear-gradient(to right, #283E51, #4B79A1);
    background: linear-gradient(to right, #283E51, #4B79A1);
    border: 1px;
    border-radius: 2px;
    pointer-events: none;
    -webkit-box-shadow: 0 1px 2px #777;
	box-shadow: 0 2px 1px #777;
}

.ui-menu .ui-menu-item a{
    background:red;
    height:10px;
    font-size:8px;
}

    body {
        overflow: hidden;
    }


#sequence {
  width: 600px;
  height: 70px;
}

#sequence text {
    font: 10px "Helvetica Neue", Helvetica, Arial, "Droid sans", sans-serif;
    fill: azure;
}

#explanation {
  position: absolute;
  top: 260px;
  left: 305px;
  width: 140px;
  text-align: center;
  color: #666;
  z-index: -1;
}

    #colorscale {
        position: relative;
    }
</style>
<link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/jqueryui/1.12.1/jquery-ui.min.css">
<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/jqueryui/1.12.1/jquery-ui.min.js"></script>
<script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js"></script>
<script src="js/colorbar.js"></script>
<!-- inspiration code etc.
https://bl.ocks.org/kerryrodden/7090426
https://bl.ocks.org/mbostock/4348373
-->
<body>

<nav class="navbar navbar-default">
    <div class="container-fluid">

        <button type="button" id="resetBtn" class="navbar-btn btn btn-default" style="left: 20px;" onclick="resetTo();">
            Reset to root
        </button>
        <div class="btn-group" data-toggle="buttons" id="colourGroup">
            <label class="btn btn-primary">
                <input type="radio" name="colourSel" id="heatmapRadio" autocomplete="off" value="heatmap-avg_nr_proteins">Avg number of Proteins
            </label>
            <label class="btn btn-primary">
                <input type="radio" name="colourSel" id="dolRadio" autocomplete="off" value="dol" checked>Domains of life
            </label>
        </div>

        <div class="nav navbar-nav navbar-right">
            <div class="input-group navbar-btn" style="margin-right: 10px;">
                <input type="text" id="search" class="form-control" placeholder="Search...">
                <div class="input-group-btn">
                    <button type="button" class="btn btn-warning" onclick="$('#search').val('');findByName();">Clear
                    </button>
                    <button type="button" class="btn btn-primary" onclick="findByName();">Search</button>
                    <button type="button" class="btn btn-info" onclick="zoomIntoName();">Zoom into</button>
                </div>
            </div>
        </div>

    </div>
</nav>
<div id="sequence"></div>
<div id="colorscale"></div>
<div id="chart">
    <div id="explanation" style="visibility: hidden;">
    </div>
</div>
<script src="//d3js.org/d3.v3.js"></script>
<script>
$(function(){
    // reset is disable when root is zoomed
    $('#resetBtn').prop('disabled', true);
    // size colouring is the default
    /* $('#dolRadio').prop('checked',true); */
    $('#dolRadio').closest("label").addClass("active");

    // dynamic function call based on the selected buttons value
    $("#colourGroup :input").change(function() {
        var func = $("input:radio[name='colourSel']:checked").val().split("-");

        if(func[1]){
            scaleName = func[1];
        } else {
            scaleName = func[0];
        }
        window.top[func[0]+"Color"]();

        var placeholder = "#colorscale";

        // init and display legend
        if(scaleName == 'avg_nr_proteins'){
            var colorbar = Colorbar()
	        .origin([15,0])
	        .scale(sqrt_color)
	        .orient("horizontal")
            .barlength(width / 3)
            .thickness(20);
            colorbarObject = d3.select(placeholder).call(colorbar);
            $(placeholder).css('visibility','visible');
        } else {
            $(placeholder).css('visibility','hidden');
        }


    });

    $("#colourGroup :input").change();
});

var top_margin = 50,
    width = window.innerWidth - 30,
    height = window.innerHeight - top_margin,
    rootNode = {},
    scaleName = "dol",
    scaleMax = 0,
    //radius = (Math.min(width, height) / 2)
    radius = (Math.min(width, height) / 2) - 10
    path = {};

// Breadcrumb dimensions: width, height, spacing, width of tip/tail.
var b = {
  w: 70, h: 20, s: 3, t: 7
};

var x = d3.scale.linear()
    .range([0, 2 * Math.PI]);

var vals = {
    "avg_nr_proteins" : [],
    "nr_genomes" : [],
    "size" : []
}

// more compact sunburst, proportianally sized root ring
//var y = d3.scale.sqrt().range([0, radius]);
// linear sized rings
var y = d3.scale.linear().range([0, radius]);

// size/area of the slice is nr_genomes
var partition = d3.layout.partition()
    .value(function(d) {
        return d.nr_genomes;
    });

var arc = d3.svg.arc()
    .startAngle(function(d) { return Math.max(0, Math.min(2 * Math.PI, x(d.x))); })
    .endAngle(function(d) { return Math.max(0, Math.min(2 * Math.PI, x(d.x + d.dx))); })
    .innerRadius(function(d) { return Math.max(0, y(d.y)); })
    .outerRadius(function(d) { return Math.max(0, y(d.y + d.dy)); });

var svg = d3.select("#chart").append("svg")
    .attr("width", width)
    .attr("height", height)
    .append("g")
    .attr("id", "container")
    .attr("transform", "translate(" + width / 2 + "," + (height / 2) + ")");


all_names = [];

$( "#search" ).autocomplete({
    source: all_names,
    delay: 200,
    minLength: 3,
    change: function( event, ui ) { findByName(); },
    select: function( event, ui ) { findByName(ui.item.value); }
});

$("#search").keyup(function (e) {
  if (e.keyCode == 13) {
      findByName();
  }
});

var augment_data = function(node) {

    if(!node.lineage) {
        node.lineage = "";
    }

    if (!node.children) {
        node.nr_genomes = (node.nr_genomes) ? node.nr_genomes : 1;
        node.avg_nr_proteins = node.nr_proteins / node.nr_genomes;
    } else {
        node.children.forEach(function(child) {
            child.lineage = node.lineage+" > "+child.name;
            child = augment_data(child)
            node.nr_genomes = (node.nr_genomes) ? node.nr_genomes + child.nr_genomes : child.nr_genomes;
            node.nr_proteins = (node.nr_proteins) ? node.nr_proteins + child.nr_proteins : child.nr_proteins;
            node.avg_nr_proteins = node.nr_proteins / node.nr_genomes;
        });
    }

    all_names.push(node.name);

    if (node.nr_genomes && vals.nr_genomes < node.nr_genomes){
        vals.nr_genomes = node.nr_genomes;
    }

    if (node.avg_nr_proteins && vals.avg_nr_proteins < node.avg_nr_proteins){
        vals.avg_nr_proteins = +node.avg_nr_proteins;
    }
    return node;
}

var div = d3.select("body").append("div")
    .attr("class", "tooltip")
    .style("opacity", 0);


var scales = {
        "avg_nr_proteins" : [],
        "dol" : []
    };

function scaleGen() {

    for (var key in vals) {

        var min = 1;
        var max = vals[key];
        //var max = 50000; // limit max val
        var steps = 10;
        var increments = ((max - min) / steps).toFixed(0);
        var arr = [];

        for (var i = 0; i <= steps; ++i) {
            arr.push(min + increments * i);
        }

        arr.push(max);

        scales[key] = arr;
    }

    //console.log(scales);

}

var linear_color = d3.scale.linear();
var log_color = d3.scale.log();
//var sqrt_color = d3.scale.sqrt();
var sqrt_color = d3.scale.pow().exponent(0.7);
var quantile_color = d3.scale.quantile();

function heatmapColor() {

    scaleMax = (d3.max(scales[scaleName])) > 50000 ? 50000 : d3.max(scales[scaleName]);

    linear_color.domain([1, scaleMax]);
    linear_color.range(["#90daac","#2d1994"]);

    log_color.domain([1, scaleMax]);
    log_color.range(["#90daac","#2d1994"]);

    sqrt_color.domain([1, 5000, 20000, scaleMax]);
    sqrt_color.range(["#90daac","#2d1994","#41b6c4", "#e58100"]);
    sqrt_color.tickFormat('.3s');

    quantile_color.domain([1, scaleMax]);
    quantile_color.range(["#90daac","#41b6c4","#2c7fb8","#253494"]);

    d3.selectAll("path").transition().attr("fill", function(d) {
        return sqrt_color(d[scaleName]);
    });
}

function dolColor() {
    d3.selectAll("path").transition().attr("fill", color);
}

function findByName(term){

    if(!term){
        var term = document.getElementById("search").value;
    }

    svg.selectAll("path")[0].forEach(function (d) {
        d3.select(d).style("opacity", 0.1); //making all paths to opacity 1
        if (d3.select(d).data()[0].name == term || term == "") {
            d3.select(d).style("opacity", 1);//making matching path's to opacity 1

        } else {
            d3.select(d).style("opacity", 0.1);//making matching path's to opacity 0.1
        }
    })

}

function zoomIntoName(){

    var term = document.getElementById("search").value;

    svg.selectAll("path")[0].forEach(function (d) {
        d3.select(d).style("opacity", 1); //making all paths to opacity 1
        if (d3.select(d).data()[0].name == term && term != "") {
            click(d3.select(d).data()[0]);
        }
    });

}

function resetTo(node) {
    if(!node){
        node = rootNode;
    }
    click(node);
}

function click(d) {
    if (d.depth > 0) {
        $('#resetBtn').prop('disabled', false);
    } else {
        $('#resetBtn').prop('disabled', true);
    }
    svg.transition()
        .duration(750)
        .tween("scale", function () {
            var xd = d3.interpolate(x.domain(), [d.x, d.x + d.dx]),
                yd = d3.interpolate(y.domain(), [d.y, 1]),
                yr = d3.interpolate(y.range(), [d.y ? 20 : 0, radius]);
            return function (t) {
                x.domain(xd(t));
                y.domain(yd(t)).range(yr(t));
            };
        })
        .selectAll("path")
        .attrTween("d", function (d) {
            return function () {
                return arc(d);
            };
        });
}

d3.select(self.frameElement).style("height", height + "px");

// Define a function that returns the color
// for a data point. The input parameter
// should be a data point as defined/created
// by the partition layout.
var color = function(d) {

    // This function builds the total
    // color palette incrementally so
    // we don't have to iterate through
    // the entire data structure.

    // We're going to need a color scale.
    // Normally we'll distribute the colors
    // in the scale to child nodes.
    var colors;

    // The root node is special since
    // we have to seed it with our
    // desired palette.
    if (!d.parent) {

        // Create a categorical color
        // scale to use both for the
        // root node's immediate
        // children. We're using the
        // 10-color predefined scale,
        // so set the domain to be
        // [0, ... 9] to ensure that
        // we can predictably generate
        // correct individual colors.

        if(scaleName != "dol"){
            colors = function () {
                return ["#E76818"];
            };
        } else {
            // 3 domains of life
            colors = d3.scale.category10().domain(d3.range(0,3));
        }


        // White for the root node
        // itself.
        d.color = "#fff";

    } else if (d.children) {

        // Since this isn't the root node,
        // we construct the scale from the
        // node's assigned color. Our scale
        // will range from darker than the
        // node's color to brigher than the
        // node's color.
        if(scaleName != "dol"){

            luminosity = [0.3, 0.5];
            initColor = "#E76818";

        } else  {

            luminosity = [0.2, 0.8];
            initColor = d.color;

        }

        var startColor = d3.hcl(initColor)
                            .darker(luminosity[0]),
            endColor   = d3.hcl(initColor)
                            .brighter(luminosity[1]);

        if(scaleName == "dol") {
            // Create the scale
            colors = d3.scale.linear()
                .interpolate(d3.interpolateHcl)
                .range([
                    startColor.toString(),
                    endColor.toString()
                ])
                .domain([0, d.children.length + 1]);
        }

    }

    if (d.children) {


        //console.log(("max value: "+scaleMax));
        // Now distribute those colors to
        // the child nodes. We want to do
        // it in sorted order, so we'll
        // have to calculate that. Because
        // JavaScript sorts arrays in place,
        // we use a mapped version.

        if(scaleName == "avg_nr_proteins"){

            //d.children.map(function (child, i) {
            d.children.map(function (child, i) {
                return {value: child.avg_nr_proteins, idx: i};
            }).forEach(function (child, i) {
                d.children[child.idx].color = quantile_color(child.value)
            });

        } else  {

            d.children.map(function (child, i) {
                return {value: child.value, idx: i};
            }).sort(function (a, b) {
                return b.value - a.value
            }).forEach(function (child, i) {
                d.children[child.idx].color = colors(i);
            });
        }

    }

    return d.color;
};

d3.json("genomes.mock.json", function (error, root) {
    if (error) throw error;

    root = augment_data(root);
    rootNode = root;

    scaleGen();
    createVisualization(root);
    initializeBreadcrumbTrail();

});

function createVisualization(root) {

    svg.append("svg:circle")
      .attr("r", radius)
      .style("opacity", 0);

    svg.selectAll("path")
        .data(partition.nodes(root))
        .enter().append("path")
        .attr("d", arc)
        .style("opacity", 1)
        .attr("fill", color)
        .on("click", click)
        .on("mouseover", mouseover)
        .append("title")
        .text(function (d) {
            return d.name;
        });

        // Add the mouseleave handler to the bounding circle.
        d3.select("#container").on("mouseleave", mouseleave);

}

// Fade all but the current sequence, and show it in the breadcrumb trail.
function mouseover(d) {
    if(d.nr_hogs){
        var hogs = "<br>Ancestral genome size: "+d.nr_hogs.toFixed(0);
    } else {
        var hogs = "";
    }

    if(d.avg_nr_proteins){
        var avg_proteins = "<br>Avg genome size: "+d.avg_nr_proteins.toFixed(0);
    } else {
        var avg_proteins = "";
    }



    d3.select("#explanation").style("visibility", "");

    var sequenceArray = getAncestors(d);
    updateBreadcrumbs(sequenceArray);

    // highlight colorbar
    if ((typeof colorbarObject !== 'undefined') && (d.avg_nr_proteins)){
        colorbarObject.pointTo(d.avg_nr_proteins.toFixed(0));
    }

    // Fade all the segments.
    d3.selectAll("path").style("opacity", 0.3);

    // Then highlight only those that are an ancestor of the current segment.
    svg.selectAll("path")
        .filter(function(node) {
            return (sequenceArray.indexOf(node) >= 0);
        })
        .style("opacity", 1);

    div.transition()
        .duration(200)
        .style("opacity", .9);
        div.html("<h5 style='vertical-align: middle;border-bottom: 1px solid black;padding-bottom: 3px;'>"+d.name+
        "<br><span style='font-size: 1em;margin-left: 5px;'>(Taxonid: "+d.taxid+
        ")</span></h5>"+
        "<p style='text-align: left;'>Genomes: "+d.nr_genomes+
        avg_proteins+
        hogs+
        "<br>Lineage: <span style='font-size: 1em;'>"+d.lineage+"</span></p>")
        .style("left", 20 + "px")
        .style("top", (d3.event.pageY - 28) + "px");


}

// Restore everything to full opacity when moving off the visualization.
function mouseleave() {

  // Hide the breadcrumb trail
  d3.select("#trail").style("visibility", "hidden");

  div.transition().duration(500).style("opacity", 0);

  // Deactivate all segments during transition.
  d3.selectAll("path").on("mouseover", null);

  // Transition each segment to full opacity and then reactivate it.
  d3.selectAll("path")
      .transition()
      .duration(1000)
      .style("opacity", 1)
      .each("end", function() {
              d3.select(this).on("mouseover", mouseover);
      });

  svg.selectAll("path").on("mouseover", mouseover);

  d3.select("#explanation")
      .style("visibility", "hidden");
}

// Given a node in a partition layout, return an array of all of its ancestor
// nodes, highest first, but excluding the root.
function getAncestors(node) {
  var path = [];
  var current = node;
  while (current.parent) {
    path.unshift(current);
    current = current.parent;
  }
  return path;
}

function initializeBreadcrumbTrail() {
  // Add the svg area.
  var trail = d3.select("#sequence").append("svg:svg")
      .attr("width", width)
      .attr("height", 45)
      .attr("id", "trail");

}

// Generate a string that describes the points of a breadcrumb polygon.
function breadcrumbPoints(d, i) {
  var points = [];
  points.push("0,0");
  points.push(b.w + ",0");
  points.push(b.w + b.t + "," + (b.h / 2));
  points.push(b.w + "," + b.h);
  points.push("0," + b.h);
  if (i > 0) { // Leftmost breadcrumb; don't include 6th vertex.
    points.push(b.t + "," + (b.h / 2));
  }
  return points.join(" ");
}

// Update the breadcrumb trail to show the current sequence and percentage.
function updateBreadcrumbs(nodeArray) {

  // Data join; key function combines name and depth (= position in sequence).
  var g = d3.select("#trail")
      .selectAll("g")
      .data(nodeArray, function(d) { return d.name + d.depth; });

  // Add breadcrumb and label for entering nodes.
  var entering = g.enter().append("svg:g");

  entering.append("svg:polygon")
      .attr("points", breadcrumbPoints)
      //.style("fill", function(d) { return colors[d.name]; });
      .attr("fill", "#4B79A1")

  entering.append("svg:text")
      .attr("x", (b.w + b.t) / 2)
      .attr("y", b.h / 2)
      .attr("dy", "0.25em")
      .attr("text-anchor", "middle")
      .text(function(d) { return subStr(d.name); });

  // Set position for entering and updating nodes.
  g.attr("transform", function(d, i) {
    return "translate(" + i * (b.w + b.s) + ", 0)";
  });

  // Remove exiting nodes.
  g.exit().remove();

  // Make the breadcrumb trail visible, if it's hidden.
  d3.select("#trail")
      .style("visibility", "");

}

// Given a node in a partition layout, return an array of all of its ancestor
// nodes, highest first, but excluding the root.
function getAncestors(node) {
  var path = [];
  var current = node;
  while (current.parent) {
    path.unshift(current);
    current = current.parent;
  }
  return path;
}

function initializeBreadcrumbTrail() {
  // Add the svg area.
  var trail = d3.select("#sequence").append("svg:svg")
      .attr("width", width)
      .attr("height", 50)
      .style("fill", "#4B79A1")
      .attr("id", "trail");

}

// Generate a string that describes the points of a breadcrumb polygon.
function breadcrumbPoints(d, i) {
  var points = [];
  points.push("0,0");
  points.push(b.w + ",0");
  points.push(b.w + b.t + "," + (b.h / 2));
  points.push(b.w + "," + b.h);
  points.push("0," + b.h);
  if (i > 0) { // Leftmost breadcrumb; don't include 6th vertex.
    points.push(b.t + "," + (b.h / 2));
  }
  return points.join(" ");
}

function subStr(string){

    var length = 12;
    var trimmedString = string.length > length ? string.substring(0, length - 3) + "..." : string.substring(0, length);
    return trimmedString;
}

</script>
